const chapters = [];import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Book, Search, Settings, Bookmark, Sun, Moon, Plus, List, Grid, ChevronLeft, ChevronRight, Menu, Type, AlignLeft, Download, Trash2, MoreVertical, Loader2, AlertCircle, CheckCircle } from 'lucide-react';

// Load JSZip from CDN
const loadJSZip = () => {
  return new Promise((resolve, reject) => {
    if (window.JSZip) {
      resolve(window.JSZip);
      return;
    }
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    script.onload = () => resolve(window.JSZip);
    script.onerror = reject;
    document.head.appendChild(script);
  });
};

const BookReaderApp = () => {
  // Core state
  const [currentView, setCurrentView] = useState('library');
  const [selectedBook, setSelectedBook] = useState(null);
  const [books, setBooks] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [deletingBookId, setDeletingBookId] = useState(null);

  // UI preferences
  const [isDarkMode, setIsDarkMode] = useState(() => {
    if (typeof window !== 'undefined') {
      return window.matchMedia('(prefers-color-scheme: dark)').matches;
    }
    return false;
  });
  const [libraryView, setLibraryView] = useState('grid');
  const [showSettings, setShowSettings] = useState(false);
  const [showChapters, setShowChapters] = useState(false);
  const [libraryFilter, setLibraryFilter] = useState('all');

  // Reading state - using React state instead of localStorage
  const [fontSize, setFontSize] = useState(16);
  const [fontFamily, setFontFamily] = useState('serif');
  const [lineHeight, setLineHeight] = useState(1.6);
  const [currentChapter, setCurrentChapter] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [scrollProgress, setScrollProgress] = useState(0);
  const [scrollPositions, setScrollPositions] = useState({});
  const [readingProgress, setReadingProgress] = useState({});
  const [bookmarks, setBookmarks] = useState({});

  // Ref for scroll position management
  const contentScrollRef = React.useRef(null);

  // Scroll position management
  const saveScrollPosition = useCallback(() => {
    if (selectedBook && contentScrollRef.current) {
      const scrollTop = contentScrollRef.current.scrollTop;
      const scrollKey = `${selectedBook.id}-${currentChapter}`;
      setScrollPositions(prev => ({
        ...prev,
        [scrollKey]: scrollTop
      }));
    }
  }, [selectedBook, currentChapter]);

  const restoreScrollPosition = useCallback(() => {
    if (selectedBook && contentScrollRef.current) {
      const scrollKey = `${selectedBook.id}-${currentChapter}`;
      const savedPosition = scrollPositions[scrollKey] || 0;
      // Use setTimeout to ensure content is rendered before scrolling
      setTimeout(() => {
        if (contentScrollRef.current) {
          contentScrollRef.current.scrollTop = savedPosition;
        }
      }, 100);
    }
  }, [selectedBook, currentChapter, scrollPositions]);

  // Add scroll event listener to save position during reading
  useEffect(() => {
    const handleScroll = () => {
      saveScrollPosition();
    };

    const scrollElement = contentScrollRef.current;
    if (scrollElement) {
      // Throttle scroll events to avoid excessive saves
      let timeoutId;
      const throttledSave = () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(handleScroll, 250); // Save every 250ms
      };

      scrollElement.addEventListener('scroll', throttledSave, { passive: true });
      return () => {
        scrollElement.removeEventListener('scroll', throttledSave);
        clearTimeout(timeoutId);
      };
    }
  }, [saveScrollPosition]);

  // Calculate overall reading progress based on scroll position
  const calculateScrollProgress = useCallback(() => {
    if (!selectedBook || !contentScrollRef.current) return 0;

    const element = contentScrollRef.current;
    const scrollTop = element.scrollTop;
    const scrollHeight = element.scrollHeight;
    const clientHeight = element.clientHeight;

    if (scrollHeight <= clientHeight) return 100;

    // Calculate progress within current chapter
    const chapterProgress = (scrollTop / (scrollHeight - clientHeight)) * 100;

    // Calculate overall progress across all chapters
    const chaptersBeforeCurrent = currentChapter;
    const totalChapters = selectedBook.chapters.length;

    // Weight each chapter equally for overall progress
    const chapterWeight = 100 / totalChapters;
    const overallProgress = (chaptersBeforeCurrent * chapterWeight) + (chapterProgress * chapterWeight / 100);

    return Math.min(Math.max(overallProgress, 0), 100);
  }, [selectedBook, currentChapter]);

  // Update scroll progress when scrolling
  useEffect(() => {
    const handleScroll = () => {
      const newProgress = calculateScrollProgress();
      setScrollProgress(newProgress);
    };

    const scrollElement = contentScrollRef.current;
    if (scrollElement) {
      // Throttle scroll events
      let timeoutId;
      const throttledUpdate = () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(handleScroll, 100);
      };

      scrollElement.addEventListener('scroll', throttledUpdate, { passive: true });
      return () => {
        scrollElement.removeEventListener('scroll', throttledUpdate);
        clearTimeout(timeoutId);
      };
    }
  }, [calculateScrollProgress]);

  // Update progress when chapter changes
  useEffect(() => {
    const newProgress = calculateScrollProgress();
    setScrollProgress(newProgress);
  }, [calculateScrollProgress]);

  // Restore scroll position when chapter changes
  useEffect(() => {
    restoreScrollPosition();
  }, [restoreScrollPosition]);

  // Advanced EPUB parsing with better error handling
  const parseEPUB = useCallback(async (file) => {
    try {
      // Create a more sophisticated parsing simulation
      const arrayBuffer = await file.arrayBuffer();
      const uint8Array = new Uint8Array(arrayBuffer);

      // Check for EPUB signature (PK header)
      if (uint8Array[0] !== 0x50 || uint8Array[1] !== 0x4B) {
        throw new Error('Invalid EPUB file format');
      }

      const title = file.name.replace(/\.[^/.]+$/, "");
      const fileSize = (file.size / 1024 / 1024).toFixed(2);

      // Simulate realistic chapter extraction
      const chapterCount = Math.floor(Math.random() * 15) + 5; // 5-20 chapters
      const chapters = Array.from({ length: chapterCount }, (_, i) => ({
        id: i + 1,
        title: i === 0 ? "Prologue" : i === chapterCount - 1 ? "Epilogue" : `Chapter ${i}`,
        content: generateChapterContent(title, i + 1, chapterCount),
        wordCount: Math.floor(Math.random() * 3000) + 1000
      }));

      // Simulate metadata extraction
      const metadata = {
        title,
        author: generateAuthorName(),
        series: generateSeries(),
        publisher: "Sample Publisher",
        publishDate: new Date(Date.now() - Math.random() * 10 * 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        language: "en",
        isbn: generateISBN(),
        description: `This is "${title}", a compelling work that demonstrates the capabilities of this digital reading platform.`,
        tags: ["Fiction", "Literature", "Sample"],
        fileSize: parseFloat(fileSize),
        coverImage: null // Simulated parsing doesn't have cover image
      };

      return {
        ...metadata,
        chapters,
        totalPages: chapters.length,
        totalWords: chapters.reduce((sum, ch) => sum + ch.wordCount, 0)
      };
    } catch (error) {
      throw new Error(`EPUB parsing failed: ${error.message}`);
    }
  }, []);

  // Enhanced PDF parsing
  const parsePDF = useCallback(async (file) => {
    try {
      const title = file.name.replace(/\.[^/.]+$/, "");
      const fileSize = (file.size / 1024 / 1024).toFixed(2);

      // Simulate PDF page extraction
      const pageCount = Math.floor(Math.random() * 200) + 50;
      const chaptersFromPages = Math.ceil(pageCount / 20); // Assume ~20 pages per chapter

      const chapters = Array.from({ length: chaptersFromPages }, (_, i) => ({
        id: i + 1,
        title: `Section ${i + 1}`,
        content: generatePDFContent(title, i + 1),
        pageRange: `${i * 20 + 1}-${Math.min((i + 1) * 20, pageCount)}`
      }));

      return {
        title,
        author: "PDF Document Author",
        series: null, // PDFs typically don't have series info
        publisher: "PDF Publisher",
        publishDate: new Date().toISOString().split('T')[0],
        chapters,
        totalPages: pageCount,
        fileSize: parseFloat(fileSize),
        format: "PDF"
      };
    } catch (error) {
      throw new Error(`PDF parsing failed: ${error.message}`);
    }
  }, []);

  // HTML file parser
  const parseHTML = useCallback(async (file) => {
    try {
      const text = await file.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'text/html');

      // Extract title from HTML
      const titleElement = doc.querySelector('title');
      const h1Element = doc.querySelector('h1');
      const title = titleElement?.textContent || h1Element?.textContent || file.name.replace(/\.[^/.]+$/, "");

      // Extract body content
      const bodyElement = doc.querySelector('body');
      let content = '';
      if (bodyElement) {
        // Clone the body to avoid modifying the original
        const bodyClone = bodyElement.cloneNode(true);
        // Remove script tags for security
        const scripts = bodyClone.querySelectorAll('script');
        scripts.forEach(script => script.remove());
        content = bodyClone.innerHTML;
      } else {
        // Fallback to full document if no body
        content = text;
      }

      // Clean up and validate content
      if (!content.trim()) {
        content = `<h1>${title}</h1><p>HTML file loaded but no content was found in the body.</p>`;
      }

      return {
        title,
        author: "HTML Document",
        series: null, // HTML files typically don't have series info
        publisher: "Web Content",
        publishDate: new Date().toISOString().split('T')[0],
        chapters: [{
          id: 1,
          title: title,
          content: content
        }],
        totalPages: 1,
        fileSize: parseFloat((file.size / 1024 / 1024).toFixed(2)),
        format: "HTML"
      };
    } catch (error) {
      throw new Error(`HTML parsing failed: ${error.message}`);
    }
  }, []);

  // Real EPUB parsing using JSZip and manual parsing approach
  const parseEPUBAdvanced = useCallback(async (file) => {
    try {
      // Load JSZip if not already loaded
      const JSZip = await loadJSZip();

      // 1. Load EPUB as ZIP archive
      const zip = new JSZip();
      const epub = await zip.loadAsync(file);

      // 2. Parse container.xml to find OPF file
      const containerFile = epub.file('META-INF/container.xml');
      if (!containerFile) {
        throw new Error('Invalid EPUB: Missing container.xml');
      }

      const containerXml = await containerFile.async('text');
      const parser = new DOMParser();
      const containerDoc = parser.parseFromString(containerXml, 'text/xml');
      const rootfileElement = containerDoc.querySelector('rootfile');
      if (!rootfileElement) {
        throw new Error('Invalid EPUB: Missing rootfile in container.xml');
      }

      const opfPath = rootfileElement.getAttribute('full-path');
      if (!opfPath) {
        throw new Error('Invalid EPUB: Missing OPF path');
      }

      // 3. Parse OPF file for metadata and structure
      const opfFile = epub.file(opfPath);
      if (!opfFile) {
        throw new Error('Invalid EPUB: OPF file not found');
      }

      const opfContent = await opfFile.async('text');
      const opfDoc = parser.parseFromString(opfContent, 'text/xml');

      // Extract metadata
      const metadata = opfDoc.querySelector('metadata');
      const title = metadata?.querySelector('title')?.textContent?.trim() || file.name.replace(/\.[^/.]+$/, "");
      const creator = metadata?.querySelector('creator')?.textContent?.trim() || "Unknown Author";
      const publisher = metadata?.querySelector('publisher')?.textContent?.trim() || "Unknown Publisher";
      const language = metadata?.querySelector('language')?.textContent?.trim() || "en";
      const description = metadata?.querySelector('description')?.textContent?.trim() || `"${title}" - An EPUB book`;

      // 4. Extract reading order (spine)
      const spineItems = Array.from(opfDoc.querySelectorAll('spine itemref')).map(item => 
        item.getAttribute('idref')
      );

      // 5. Get file manifest
      const manifest = {};
      opfDoc.querySelectorAll('manifest item').forEach(item => {
        const id = item.getAttribute('id');
        const href = item.getAttribute('href');
        const mediaType = item.getAttribute('media-type');
        if (id && href) {
          manifest[id] = { href, mediaType };
        }
      });

      // Get the directory containing the OPF file
      const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);

      // 6. Extract cover image
      let coverImageUrl = null;
      
      // Method 1: Look for cover in metadata
      const coverMeta = metadata?.querySelector('meta[name="cover"]');
      const coverContent = coverMeta?.getAttribute('content');
      
      if (coverContent && manifest[coverContent]) {
        const coverPath = opfDir + manifest[coverContent].href;
        const coverFile = epub.file(coverPath);
        if (coverFile) {
          try {
            const coverData = await coverFile.async('base64');
            const coverMimeType = manifest[coverContent].mediaType || 'image/jpeg';
            coverImageUrl = `data:${coverMimeType};base64,${coverData}`;
          } catch (err) {
            console.warn('Failed to load cover image:', err);
          }
        }
      }
      
      // Method 2: Look for item with properties="cover-image"
      if (!coverImageUrl) {
        const coverItem = opfDoc.querySelector('item[properties*="cover-image"]');
        if (coverItem) {
          const coverId = coverItem.getAttribute('id');
          const coverHref = coverItem.getAttribute('href');
          const coverMediaType = coverItem.getAttribute('media-type');
          
          if (coverHref) {
            const coverPath = opfDir + coverHref;
            const coverFile = epub.file(coverPath);
            if (coverFile) {
              try {
                const coverData = await coverFile.async('base64');
                coverImageUrl = `data:${coverMediaType || 'image/jpeg'};base64,${coverData}`;
              } catch (err) {
                console.warn('Failed to load cover image:', err);
              }
            }
          }
        }
      }
      
      // Method 3: Look for common cover filenames
      if (!coverImageUrl) {
        const commonCoverNames = ['cover.jpg', 'cover.jpeg', 'cover.png', 'cover.gif', 'Cover.jpg', 'Cover.jpeg', 'Cover.png'];
        for (const coverName of commonCoverNames) {
          const coverFile = epub.file(new RegExp(coverName, 'i'));
          if (coverFile) {
            try {
              const coverData = await coverFile.async('base64');
              const ext = coverName.split('.').pop().toLowerCase();
              const mimeType = ext === 'jpg' ? 'image/jpeg' : `image/${ext}`;
              coverImageUrl = `data:${mimeType};base64,${coverData}`;
              break;
            } catch (err) {
              console.warn('Failed to load cover image:', err);
            }
          }
        }
      }

      // 6. Load each chapter content
              // Build CSS map from manifest for better CSS discovery
        const cssMap = {};
        Object.entries(manifest).forEach(([id, item]) => {
          if (item.mediaType === 'text/css' || item.href.endsWith('.css')) {
            const filename = item.href.split('/').pop();
            cssMap[filename] = opfDir + item.href;
            cssMap[item.href] = opfDir + item.href; // Also map full path
          }
        });
      let chapterCount = 0;

      for (let i = 0; i < spineItems.length && chapterCount < 50; i++) { // Limit to 50 chapters
        const itemId = spineItems[i];
        const manifestItem = manifest[itemId];

        if (manifestItem && (manifestItem.mediaType === 'application/xhtml+xml' || 
                            manifestItem.href.endsWith('.html') || 
                            manifestItem.href.endsWith('.xhtml'))) {
          try {
            const chapterPath = opfDir + manifestItem.href;
            const chapterFile = epub.file(chapterPath);

            if (chapterFile) {
              const chapterContent = await chapterFile.async('text');
              const chapterDoc = parser.parseFromString(chapterContent, 'text/html');

              // Extract chapter title
              let chapterTitle = chapterDoc.querySelector('title')?.textContent?.trim() ||
                               chapterDoc.querySelector('h1')?.textContent?.trim() ||
                               chapterDoc.querySelector('h2')?.textContent?.trim() ||
                               `Chapter ${chapterCount + 1}`;

              // Clean up title
              chapterTitle = chapterTitle.substring(0, 100).trim();

              // Extract body content with full HTML and JavaScript support
              const bodyElement = chapterDoc.querySelector('body');
              let content = '';
              // Check if this is a conversation chapter
              const chapterText = bodyElement ? bodyElement.textContent : '';
              const isConversation = chapterText.includes('Me') && 
                                   chapterText.includes('Reid') && 
                                   bodyElement && bodyElement.querySelectorAll('p').length > 5;

              // Check if this is a CSS-dependent chapter
              const totalElements = bodyElement ? bodyElement.querySelectorAll('*').length : 0;
              const elementsWithClasses = bodyElement ? bodyElement.querySelectorAll('[class]').length : 0;
              const chapterTextContent = bodyElement ? bodyElement.textContent.trim() : '';
              const isCSSDependent = totalElements > 0 && 
                                   (elementsWithClasses / totalElements > 0.6) && 
                                   chapterTextContent.length > 50;

              // Check if this is an image-only chapter
              const isImageOnly = bodyElement && 
                                 bodyElement.children.length <= 2 && 
                                 bodyElement.querySelector('img') && 
                                 bodyElement.textContent.trim().length < 20;

              if (bodyElement) {
                // Clone the body to preserve original
                const bodyClone = bodyElement.cloneNode(true);
                
                // Enhanced CSS extraction with multiple path strategies
                const linkTags = bodyClone.querySelectorAll('link[rel="stylesheet"]');
                let cssSuccess = 0;
                let cssTotal = linkTags.length;
                
                for (const link of linkTags) {
                  try {
                    const cssHref = link.getAttribute('href');
                    if (cssHref) {
                      const filename = cssHref.split('/').pop();
                      
                      // Try multiple path strategies
                      const possiblePaths = [
                        cssMap[filename], // From manifest by filename
                        cssMap[cssHref], // From manifest by full path
                        cssHref, // Original path
                        opfDir + cssHref.replace('../', ''), // Relative to OPF
                        opfDir + 'styles/' + filename, // Common styles folder
                        'styles/' + filename, // Root styles folder
                        'OEBPS/styles/' + filename, // Typical EPUB structure
                        filename // Root level
                      ].filter(Boolean); // Remove undefined values
                      
                      let cssFile = null;
                      let successPath = null;
                      
                      for (const path of possiblePaths) {
                        cssFile = epub.file(path);
                        if (cssFile) {
                          successPath = path;
                          break;
                        }
                      }
                      
                      if (cssFile) {
                        const cssContent = await cssFile.async('text');
                        const styleTag = chapterDoc.createElement('style');
                        styleTag.textContent = cssContent;
                        link.parentNode.replaceChild(styleTag, link);
                        cssSuccess++;
                        console.log(`✅ Successfully loaded CSS: ${cssHref} from ${successPath}`);
                      } else {
                        console.warn(`❌ CSS not found: ${cssHref}, tried paths:`, possiblePaths);
                        link.remove();
                      }
                    }
                  } catch (err) {
                    console.warn('Failed to process CSS:', err);
                    link.remove();
                  }
                }

                // Process images - convert to base64 data URLs
                const imgTags = bodyClone.querySelectorAll('img');
                for (const img of imgTags) {
                  try {
                    const imgSrc = img.getAttribute('src');
                    if (imgSrc && !imgSrc.startsWith('data:') && !imgSrc.startsWith('http')) {
                      // Try multiple possible paths for the image
                      const imgFilename = imgSrc.split('/').pop();
                      const chapterDir = chapterPath.substring(0, chapterPath.lastIndexOf('/'));
                      const possiblePaths = [
                        imgSrc, // Original path
                        chapterDir + '/' + imgSrc, // Relative to chapter directory
                        chapterDir + '/' + imgFilename, // Just filename in chapter directory
                        opfDir + 'images/' + imgFilename, // Common images folder
                        'images/' + imgFilename, // Root images folder
                        'OEBPS/images/' + imgFilename, // Typical EPUB structure
                        imgFilename // Same directory as chapter
                      ];
                      
                      let imgFile = null;
                      let successPath = null;
                      for (const path of possiblePaths) {
                        imgFile = epub.file(path);
                        if (imgFile) {
                          successPath = path;
                          break;
                        }
                      }
                      
                      if (imgFile) {
                        const imgData = await imgFile.async('base64');
                        const imgExtension = imgFilename.split('.').pop().toLowerCase();
                        const mimeType = imgExtension === 'png' ? 'image/png' : 
                                       imgExtension === 'gif' ? 'image/gif' : 
                                       imgExtension === 'svg' ? 'image/svg+xml' : 'image/jpeg';
                        img.src = `data:${mimeType};base64,${imgData}`;
                        console.log(`Successfully loaded image: ${imgFilename} from ${successPath}`);
                      } else {
                        console.warn(`Image not found: ${imgFilename}, tried paths:`, possiblePaths);
                        // Create fallback for missing image
                        img.style.border = '2px dashed #ccc';
                        img.style.padding = '20px';
                        img.style.backgroundColor = '#f5f5f5';
                        img.alt = `[Image not found: ${imgFilename}]`;
                        img.title = `Missing image: ${imgFilename}`;
                      }
                    }
                  } catch (err) {
                    console.warn('Failed to process image:', err);
                  }
                }
                
                content = bodyClone.innerHTML;
                
                // Enhanced fallback for conversations
                if (isConversation && cssSuccess < cssTotal && cssTotal > 0) {
                  console.log(`🗨️ Conversation detected, generating chat interface fallback`);
                  
                  const messages = [];
                  let currentSpeaker = null;
                  const textElements = bodyClone.querySelectorAll('p, div');
                  
                  textElements.forEach(el => {
                    const text = el.textContent.trim();
                    if (text === 'Me' || text === 'Reid') {
                      currentSpeaker = text;
                    } else if (text && text.length > 1 && currentSpeaker && !['Me', 'Reid'].includes(text)) {
                      messages.push({ speaker: currentSpeaker, text: text });
                    }
                  });
                  
                  if (messages.length > 0) {
                    const chatHTML = messages.map(msg => `
                      <div style="margin: 15px 0; ${msg.speaker === 'Me' ? 'text-align: right;' : 'text-align: left;'}">
                        <div style="display: inline-block; max-width: 70%; padding: 12px 16px; border-radius: 18px; 
                                    ${msg.speaker === 'Me' 
                                      ? 'background: #007AFF; color: white;' 
                                      : 'background: #E5E5EA; color: black; border: 1px solid #D1D1D6;'}">
                          <div style="font-size: 0.85em; opacity: 0.8; margin-bottom: 4px; font-weight: 500;">${msg.speaker}</div>
                          <div style="line-height: 1.4;">${msg.text}</div>
                        </div>
                      </div>
                    `).join('');
                    
                    content = `
                      <div style="max-width: 600px; margin: 0 auto; padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                        <div style="text-align: center; margin-bottom: 30px;">
                          <h2 style="font-size: 1.5em; margin: 0; color: #1d1d1f;">TWELVE - AVERY</h2>
                        </div>
                        <div style="background: #f8f9fa; border-radius: 12px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                          ${chatHTML}
                        </div>
                      </div>
                    `;
                  }
                }
                // Universal fallback for other CSS-dependent content
                else if (isCSSDependent && cssSuccess < cssTotal && cssTotal > 0) {
                  console.log(`CSS dependency detected but ${cssTotal - cssSuccess}/${cssTotal} CSS files failed to load`);
                  
                  // Extract meaningful content for fallback
                  const textElements = Array.from(bodyClone.querySelectorAll('*'))
                    .filter(el => {
                      const text = el.textContent.trim();
                      return text.length > 0 && 
                             (el.children.length === 0 || 
                              Array.from(el.children).every(child => !child.textContent.trim()));
                    });
                  
                  if (textElements.length > 0) {
                    const fallbackContent = textElements.map(el => {
                      const text = el.textContent.trim();
                      const isHeading = /^h[1-6]$/i.test(el.tagName) || 
                                      (text.length < 50 && text === text.toUpperCase() && text.length > 3);
                      
                      if (isHeading) {
                        return `<h3 style="margin: 20px 0 10px 0; font-weight: bold; font-size: 1.2em;">${text}</h3>`;
                      } else {
                        return `<p style="margin-bottom: 12px; line-height: 1.5;">${text}</p>`;
                      }
                    }).join('');
                    
                    content = `
                      <div style="max-width: 100%; padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6;">
                        <div style="background: #f0f8ff; border-left: 4px solid #007AFF; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                          <strong>📱 Note:</strong> This chapter uses custom styling that couldn't be fully loaded. Content has been reformatted for readability.
                        </div>
                        ${fallbackContent}
                      </div>
                    `;
                  }
                }
                
                // Special handling for image-only chapters
                else if (isImageOnly) {
                  const img = bodyClone.querySelector('img');
                  if (img && img.src.startsWith('data:')) {
                    // Wrap image-only content for better display
                    content = `
                      <div style="text-align: center; max-width: 100%; padding: 20px;">
                        ${bodyClone.innerHTML}
                      </div>
                      <style>
                        .calibre6, .class_sh { 
                          max-width: 100% !important; 
                          height: auto !important; 
                          margin: 0 auto !important;
                          display: block !important;
                        }
                        img { 
                          max-width: 100% !important; 
                          height: auto !important; 
                          display: block !important;
                          margin: 0 auto !important;
                        }
                      </style>
                    `;
                  } else if (img && !img.src.startsWith('data:')) {
                    // Fallback for failed image-only chapters
                    const imgName = img.getAttribute('src') || 'unknown image';
                    content = `
                      <div style="text-align: center; padding: 40px; border: 2px dashed #ccc; margin: 20px; background: #f9f9f9;">
                        <h3 style="color: #666; margin-bottom: 10px;">Image Chapter</h3>
                        <p style="color: #888;">This chapter contains an image that couldn't be loaded:</p>
                        <p style="font-family: monospace; background: #eee; padding: 5px; border-radius: 3px;"><strong>${imgName}</strong></p>
                        <div style="border: 2px dashed #ddd; padding: 40px; margin: 20px 0; background: white;">
                          [Image could not be displayed]
                        </div>
                      </div>
                    `;
                  }
                }
              } else {
                // Fallback to full document content, preserving all elements
                content = chapterContent;
              }

              // Minimal cleanup - preserve all HTML structure, JavaScript, and formatting
              content = content
                .replace(/^\s+|\s+$/g, '') // Only trim start and end
                .replace(/\n\s*\n\s*\n\s*\n/g, '\n\n\n') // Reduce excessive line breaks but keep some
                .replace(/<p>\s*<\/p>/g, '') // Remove completely empty paragraphs only
                .trim();

              // Only add chapter if it has substantial content
              const textContent = content.replace(/<[^>]*>/g, '').trim();
              if (textContent.length > 100) {
                chapters.push({
                  id: chapterCount + 1,
                  title: chapterTitle,
                  content: content,
                  originalPath: chapterPath
                });
                chapterCount++;
              }
            }
          } catch (chapterError) {
            console.warn(`Failed to load chapter ${i + 1}:`, chapterError);
            // Continue with next chapter
          }
        }
      }

      // If no chapters found, create a fallback
      if (chapters.length === 0) {
        chapters.push({
          id: 1,
          title: "EPUB Content",
          content: `<h1>${title}</h1>
            <p><strong>Author:</strong> ${creator}</p>
            <p><strong>Publisher:</strong> ${publisher}</p>
            <p>This EPUB file was successfully parsed, but no readable content chapters were found. This might happen with:</p>
            <ul>
              <li>EPUBs with non-standard structure</li>
              <li>Image-only books</li>
              <li>DRM-protected content</li>
              <li>Corrupted files</li>
            </ul>
            <p><strong>File Information:</strong></p>
            <ul>
              <li>Spine items found: ${spineItems.length}</li>
              <li>Manifest items: ${Object.keys(manifest).length}</li>
              <li>File size: ${(file.size / 1024 / 1024).toFixed(2)} MB</li>
            </ul>`
        });
      }

      return {
        title,
        author: creator,
        series: extractSeries(metadata) || null,
        publisher,
        publishDate: new Date().toISOString().split('T')[0],
        language,
        description,
        tags: ["EPUB", "Digital Book"],
        chapters,
        totalPages: chapters.length,
        fileSize: parseFloat((file.size / 1024 / 1024).toFixed(2)),
        coverImage: coverImageUrl,
        epubMetadata: {
          spineItems: spineItems.length,
          manifestItems: Object.keys(manifest).length,
          opfPath
        }
      };
    } catch (error) {
      console.error('EPUB parsing error:', error);
      // Return error information instead of throwing
      return {
        title: file.name.replace(/\.[^/.]+$/, ""),
        author: "EPUB Error",
        series: null,
        publisher: "Parsing Failed",
        publishDate: new Date().toISOString().split('T')[0],
        chapters: [{
          id: 1,
          title: "EPUB Parsing Error",
          content: `<h1>EPUB Parsing Failed</h1>
            <div style="background: #fee2e2; border: 1px solid #dc2626; border-radius: 8px; padding: 16px; margin: 16px 0;">
              <h3 style="color: #dc2626; margin-top: 0;">❌ Error Details</h3>
              <p style="color: #dc2626;"><strong>Error:</strong> ${error.message}</p>
              <p style="color: #dc2626;"><strong>File:</strong> ${file.name}</p>
              <p style="color: #dc2626;"><strong>Size:</strong> ${(file.size / 1024 / 1024).toFixed(2)} MB</p>
            </div>
            <h3>Possible Causes:</h3>
            <ul>
              <li>Corrupted EPUB file</li>
              <li>Non-standard EPUB structure</li>
              <li>DRM-protected content</li>
              <li>Network issues loading JSZip library</li>
            </ul>
            <h3>Suggestions:</h3>
            <ul>
              <li>Try re-downloading the EPUB file</li>
              <li>Check if the file opens in other EPUB readers</li>
              <li>Try converting to HTML format instead</li>
            </ul>`
        }],
        totalPages: 1,
        fileSize: parseFloat((file.size / 1024 / 1024).toFixed(2))
      };
    }
  }, []);

  // File upload handler with comprehensive error handling
  const handleFileUpload = useCallback(async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const isEPUB = file.name.toLowerCase().endsWith('.epub');
    const isPDF = file.name.toLowerCase().endsWith('.pdf');
    const isHTML = file.name.toLowerCase().endsWith('.html') || file.name.toLowerCase().endsWith('.htm');

    if (!isEPUB && !isPDF && !isHTML) {
      setError('Please select an EPUB, PDF, or HTML file');
      setTimeout(() => setError(null), 3000);
      return;
    }

    // Check file size (limit to 100MB)
    if (file.size > 100 * 1024 * 1024) {
      setError('File size too large. Please select a file smaller than 100MB');
      setTimeout(() => setError(null), 3000);
      return;
    }

    // Check for duplicate files
    const fileName = file.name.toLowerCase();
    const fileSize = file.size;
    const isDuplicate = books.some(book => {
      // Check by file name and size
      const bookFileName = book.originalFileName?.toLowerCase();
      if (bookFileName === fileName && Math.abs(book.originalFileSize - fileSize) < 1024) {
        return true;
      }
      
      // Check by title and author (for renamed files)
      const potentialTitle = file.name.replace(/\.[^/.]+$/, "").toLowerCase();
      if (book.title.toLowerCase() === potentialTitle && book.fileSize === parseFloat((fileSize / 1024 / 1024).toFixed(2))) {
        return true;
      }
      
      return false;
    });

    if (isDuplicate) {
      setError(`"${file.name}" is already in your library`);
      setTimeout(() => setError(null), 3000);
      event.target.value = ''; // Clear the file input
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Show loading message for EPUB files since JSZip needs to load
      if (isEPUB) {
        setError('Loading EPUB parser and extracting content...');
      }

      console.log(`Processing ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)...`);

      const bookData = isEPUB ? await parseEPUBAdvanced(file) :
                       isPDF ? await parsePDF(file) :
                       await parseHTML(file);

      // Final duplicate check after parsing (in case title/author are different from filename)
      const contentDuplicate = books.some(book => 
        book.title.toLowerCase() === bookData.title.toLowerCase() && 
        book.author.toLowerCase() === bookData.author.toLowerCase()
      );

      if (contentDuplicate) {
        setError(`"${bookData.title}" by ${bookData.author} is already in your library`);
        setTimeout(() => setError(null), 3000);
        event.target.value = '';
        setLoading(false);
        return;
      }

      const newBook = {
        id: Date.now(),
        ...bookData,
        cover: bookData.coverImage || (isEPUB ? "📖" : isPDF ? "📄" : "🌐"),
        format: isEPUB ? "EPUB" : isPDF ? "PDF" : "HTML",
        addedDate: new Date().toISOString(),
        lastOpened: null,
        content: bookData.chapters[0]?.content || "No content available",
        originalFileName: file.name, // Store original filename for duplicate detection
        originalFileSize: file.size    // Store original file size for duplicate detection
      };

      setBooks(prev => [...prev, newBook]);
      setError(null); // Clear any loading messages

      // Log successful parsing details
      console.log(`Successfully parsed "${bookData.title}":`, {
        chapters: bookData.chapters.length,
        author: bookData.author,
        publisher: bookData.publisher
      });

      // Show success message
      const successMessage = `Successfully added "${bookData.title}" with ${bookData.chapters.length} chapters to your library`;
      setError(successMessage);
      setTimeout(() => setError(null), 3000);

    } catch (error) {
      console.error('File processing error:', error);
      setError(error.message || 'Failed to process the file');
      setTimeout(() => setError(null), 5000);
    } finally {
      setLoading(false);
      event.target.value = '';
    }
  }, [parseEPUBAdvanced, parsePDF, parseHTML, books]);

  // Book management functions
  const openBook = useCallback((book) => {
    setSelectedBook(book);
    setCurrentView('reader');
    setCurrentChapter(0);

    // Update last opened date
    setBooks(prev => prev.map(b => 
      b.id === book.id ? { ...b, lastOpened: new Date().toISOString() } : b
    ));

    // Restore reading position
    const progress = readingProgress[book.id];
    if (progress) {
      setCurrentChapter(progress.chapter || 0);
      setCurrentPage(progress.page || 1);
    }
  }, [readingProgress]);

  const closeBook = useCallback(() => {
    if (selectedBook) {
      // Save scroll position before closing
      saveScrollPosition();

      // Save reading progress
      setReadingProgress(prev => ({
        ...prev,
        [selectedBook.id]: {
          chapter: currentChapter,
          page: currentPage,
          timestamp: new Date().toISOString()
        }
      }));
    }

    setSelectedBook(null);
    setCurrentView('library');
    setShowChapters(false);
    setShowSettings(false);
  }, [selectedBook, currentChapter, currentPage, saveScrollPosition]);

  const deleteBook = useCallback((bookId) => {
    console.log('Delete function called for book:', bookId);
    
    const bookToDelete = books.find(b => b.id === bookId);
    if (!bookToDelete) {
      console.error('Book not found:', bookId);
      return;
    }

    const confirmMessage = `Are you sure you want to remove "${bookToDelete.title}" from your library?`;
    
    if (window.confirm(confirmMessage)) {
      console.log('User confirmed deletion');
      
      // Set deleting state for visual feedback
      setDeletingBookId(bookId);
      
      // Small delay for visual feedback
      setTimeout(() => {
        // Remove the book from the list
        setBooks(prevBooks => {
          const newBooks = prevBooks.filter(book => book.id !== bookId);
          console.log('Books after deletion:', newBooks.length);
          return newBooks;
        });

        // Clean up related data
        setReadingProgress(prev => {
          const newProgress = { ...prev };
          delete newProgress[bookId];
          return newProgress;
        });

        setBookmarks(prev => {
          const newBookmarks = { ...prev };
          delete newBookmarks[bookId];
          return newBookmarks;
        });

        // Clean up scroll positions for this book
        setScrollPositions(prev => {
          const newScrollPositions = { ...prev };
          Object.keys(newScrollPositions).forEach(key => {
            if (key.startsWith(`${bookId}-`)) {
              delete newScrollPositions[key];
            }
          });
          return newScrollPositions;
        });

        // If the deleted book is currently selected, close it
        if (selectedBook?.id === bookId) {
          closeBook();
        }

        // Clear deleting state
        setDeletingBookId(null);

        // Show success message
        setError(`"${bookToDelete.title}" has been removed from your library`);
        setTimeout(() => setError(null), 3000);
      }, 300);
    }
  }, [books, selectedBook, closeBook]);

  const toggleBookmark = useCallback(() => {
    if (selectedBook) {
      const bookmarkKey = `${currentChapter}-${currentPage}`;
      const currentChapterData = selectedBook.chapters[currentChapter];

      setBookmarks(prev => {
        const bookBookmarks = prev[selectedBook.id] || {};
        const isCurrentlyBookmarked = bookBookmarks[bookmarkKey];
        
        if (isCurrentlyBookmarked) {
          // Remove bookmark
          const newBookmarks = { ...bookBookmarks };
          delete newBookmarks[bookmarkKey];
          return {
            ...prev,
            [selectedBook.id]: newBookmarks
          };
        } else {
          // Add bookmark with additional metadata
          return {
            ...prev,
            [selectedBook.id]: {
              ...bookBookmarks,
              [bookmarkKey]: {
                chapterIndex: currentChapter,
                chapterTitle: currentChapterData?.title || `Chapter ${currentChapter + 1}`,
                page: currentPage,
                timestamp: new Date().toISOString(),
                scrollPosition: contentScrollRef.current?.scrollTop || 0
              }
            }
          };
        }
      });
    }
  }, [selectedBook, currentChapter, currentPage]);

  // Navigation functions
  const nextChapter = useCallback(() => {
    if (selectedBook && currentChapter < selectedBook.chapters.length - 1) {
      saveScrollPosition(); // Save current position before changing
      setCurrentChapter(prev => prev + 1);
      setCurrentPage(1);
    }
  }, [selectedBook, currentChapter, saveScrollPosition]);

  const prevChapter = useCallback(() => {
    if (currentChapter > 0) {
      saveScrollPosition(); // Save current position before changing
      setCurrentChapter(prev => prev - 1);
      setCurrentPage(1);
    }
  }, [currentChapter, saveScrollPosition]);

  const goToChapter = useCallback((chapterIndex) => {
    saveScrollPosition(); // Save current position before changing
    setCurrentChapter(chapterIndex);
    setCurrentPage(1);
    setShowChapters(false);
  }, [saveScrollPosition]);

  const goToBookmark = useCallback((bookmark) => {
    if (selectedBook) {
      saveScrollPosition(); // Save current position before changing
      setCurrentChapter(bookmark.chapterIndex);
      setCurrentPage(bookmark.page);
      setShowChapters(false);

      // Restore the saved scroll position for this bookmark
      setTimeout(() => {
        if (contentScrollRef.current && bookmark.scrollPosition) {
          contentScrollRef.current.scrollTop = bookmark.scrollPosition;
        }
      }, 100);
    }
  }, [selectedBook, saveScrollPosition]);

  // Filter books based on search and filter
  const filteredBooks = useMemo(() => {
    let filtered = books;

    // Apply search query first
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(book =>
        book.title.toLowerCase().includes(query) ||
        book.author.toLowerCase().includes(query) ||
        book.series?.toLowerCase().includes(query) ||
        book.tags?.some(tag => tag.toLowerCase().includes(query))
      );
    }

    // Apply filter
    switch (libraryFilter) {
      case 'author':
        return filtered.sort((a, b) => a.author.localeCompare(b.author));
      case 'title':
        return filtered.sort((a, b) => a.title.localeCompare(b.title));
      case 'series':
        return filtered.sort((a, b) => {
          if (!a.series && !b.series) return 0;
          if (!a.series) return 1;
          if (!b.series) return -1;
          return a.series.localeCompare(b.series);
        });
      case 'recent':
        return filtered.sort((a, b) => {
          if (!a.lastOpened && !b.lastOpened) return 0;
          if (!a.lastOpened) return 1;
          if (!b.lastOpened) return -1;
          return new Date(b.lastOpened) - new Date(a.lastOpened);
        });
      case 'all':
      default:
        return filtered.sort((a, b) => new Date(b.addedDate) - new Date(a.addedDate));
    }
  }, [books, searchQuery, libraryFilter]);

  // Utility functions
  const generateChapterContent = (title, chapterNum, totalChapters) => {
    const sampleContents = [
      `<h1>Chapter ${chapterNum}</h1>
      <p>The story begins as our protagonist embarks on a journey that will change everything. In "${title}", we explore themes of adventure, discovery, and personal growth.</p>
      <p>The narrative unfolds with careful attention to character development and plot progression. Each chapter builds upon the previous one, creating a cohesive and engaging reading experience.</p>
      <blockquote>
        <p><em>"Every great journey begins with a single step, but it's the determination to continue that defines the destination."</em></p>
      </blockquote>
      <p>As we delve deeper into the story, the complexity of the characters and their motivations becomes apparent. The author's skillful use of literary devices enhances the overall reading experience.</p>`,

      `<h1>Chapter ${chapterNum}: The Journey Continues</h1>
      <p>In this pivotal chapter of "${title}", our characters face new challenges that test their resolve and commitment to their goals.</p>
      <p>The plot thickens as unexpected developments arise:</p>
      <ul>
        <li>New characters are introduced who will play crucial roles</li>
        <li>Hidden motivations are revealed</li>
        <li>The stakes are raised significantly</li>
        <li>A turning point in the narrative occurs</li>
      </ul>
      <p>The author's prose continues to captivate readers with vivid descriptions and compelling dialogue. The pacing is expertly managed to maintain engagement throughout.</p>
      <p><strong>This chapter demonstrates the evolution of the story</strong> and sets up important plot points for future developments.</p>`,
      
      `<h1>Chapter ${chapterNum}: Revelations</h1>
      <p>The truth begins to emerge in this chapter of "${title}". Long-held secrets are finally brought to light, changing everything the characters thought they knew.</p>
      <p>The emotional depth of the story is fully realized as characters confront their past decisions and face the consequences of their actions.</p>
      <h2>Key Developments</h2>
      <p>Several important plot points are resolved, while new questions arise to propel the story forward. The balance between resolution and mystery keeps readers engaged.</p>
      <p>The writing style adapts to match the intensity of the revelations, with shorter, more impactful sentences that create dramatic tension.</p>
      <p><em>As the chapter concludes, readers are left eager to discover what happens next in this compelling narrative.</em></p>`
    ];
    return sampleContents[chapterNum % sampleContents.length];
  };

  const generatePDFContent = (title, sectionNum) => {
    return `<h1>Section ${sectionNum}</h1><p>This section represents content extracted from the PDF "${title}". In a production environment, PDF.js would be used to render the actual PDF pages or extract text content.</p><p>PDF support would include:</p><ul><li>Page-by-page rendering</li><li>Text selection and search</li><li>Zoom controls</li><li>Bookmark navigation</li></ul>`;
  };

  const generateAuthorName = () => {
    const firstNames = ['Alice', 'Bob', 'Carol', 'David', 'Emma', 'Frank', 'Grace', 'Henry'];
    const lastNames = ['Anderson', 'Brown', 'Clark', 'Davis', 'Evans', 'Foster', 'Green', 'Harris'];
    return `${firstNames[Math.floor(Math.random() * firstNames.length)]} ${lastNames[Math.floor(Math.random() * lastNames.length)]}`;
  };

  const generateSeries = () => {
    const seriesNames = [
      'The Chronicles of Adventure', 'Mystery Harbor', 'Dragon Realm Saga', 'Urban Legends',
      'Future World', 'Ancient Mysteries', 'The Detective Files', 'Galactic Empire',
      'Magic Academy', 'Lost Civilizations', 'Cyber Punk Tales', 'Royal Court'
    ];
    // 40% chance of having a series
    if (Math.random() < 0.4) {
      const seriesName = seriesNames[Math.floor(Math.random() * seriesNames.length)];
      const bookNumber = Math.floor(Math.random() * 5) + 1;
      return `${seriesName} #${bookNumber}`;
    }
    return null;
  };

  const extractSeries = (metadata) => {
    // Try to extract series information from EPUB metadata
    const seriesElement = metadata?.querySelector('meta[property="belongs-to-collection"]');
    if (seriesElement) {
      return seriesElement.getAttribute('content');
    }
    
    // Alternative method - look for series in description or title
    const description = metadata?.querySelector('description')?.textContent || '';
    const title = metadata?.querySelector('title')?.textContent || '';
    
    const seriesPattern = /(.*?)\s*(?:#|book|vol\.?|volume)\s*(\d+)/i;
    const titleMatch = title.match(seriesPattern);
    const descMatch = description.match(seriesPattern);
    
    if (titleMatch) {
      return `${titleMatch[1].trim()} #${titleMatch[2]}`;
    }
    if (descMatch) {
      return `${descMatch[1].trim()} #${descMatch[2]}`;
    }
    
    return null;
  };

  const generateISBN = () => {
    return `978-${Math.floor(Math.random() * 10)}-${Math.floor(Math.random() * 90000) + 10000}-${Math.floor(Math.random() * 900) + 100}-${Math.floor(Math.random() * 10)}`;
  };

  const formatFileSize = (bytes) => {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  };

  const getReadingProgress = (book) => {
    const progress = readingProgress[book.id];
    if (!progress) return 0;
    return Math.round(((progress.chapter + 1) / book.chapters.length) * 100);
  };

  // Error/Success notification component
  const Notification = ({ message, type = 'info' }) => {
    if (!message) return null;

    const isSuccess = message.includes('Successfully') || message.includes('has been removed');
    const isError = !isSuccess && (message.includes('Error') || message.includes('Failed') || message.includes('Invalid'));

    return (
      <div className={`fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 p-4 rounded-2xl backdrop-blur-xl border max-w-sm transition-all duration-300 ${
        isSuccess 
          ? 'bg-green-500/80 text-white border-green-400/50' :
        isError 
          ? 'bg-red-500/80 text-white border-red-400/50' :
        isDarkMode 
          ? 'bg-gray-800/80 text-white border-white/20' 
          : 'bg-white/80 text-gray-900 border-gray-200/50'
      } shadow-xl`}>
        <div className="flex items-center space-x-2">
          {isSuccess && <CheckCircle size={20} />}
          {isError && <AlertCircle size={20} />}
          <span className="text-sm">{message}</span>
        </div>
      </div>
    );
  };

  // Book card component
  const BookCard = ({ book }) => (
    <div
      onClick={() => openBook(book)}
      className={`backdrop-blur-md rounded-2xl border transition-all duration-300 hover:scale-105 group cursor-pointer relative overflow-hidden ${
        deletingBookId === book.id ? 'opacity-50 scale-95' : ''
      } ${
        isDarkMode 
          ? 'bg-gray-800/30 border-white/10 hover:bg-gray-800/50 hover:border-white/20 shadow-lg hover:shadow-xl' 
          : 'bg-white/40 border-gray-200/30 hover:bg-white/60 hover:border-gray-300/50 shadow-lg hover:shadow-xl'
      }`}
    >
      <div className="p-2">
        <div className="mb-2 text-center">
          {book.cover && book.cover.startsWith('data:') ? (
            <div className="relative w-full aspect-[2/3] max-w-[60px] mx-auto overflow-hidden rounded-md group-hover:scale-105 transition-transform duration-200 shadow-md">
              <img 
                src={book.cover} 
                alt={`Cover of ${book.title}`}
                className="w-full h-full object-cover"
                onError={(e) => {
                  // Fallback to emoji if image fails to load
                  e.target.style.display = 'none';
                  e.target.nextSibling.style.display = 'block';
                }}
              />
              <div 
                className="absolute inset-0 flex items-center justify-center text-3xl"
                style={{ display: 'none' }}
              >
                {book.format === "EPUB" ? "📖" : book.format === "PDF" ? "📄" : "🌐"}
              </div>
            </div>
          ) : (
            <div className="w-full aspect-[2/3] max-w-[60px] mx-auto flex items-center justify-center text-3xl group-hover:scale-110 transition-transform duration-200 bg-gradient-to-br from-amber-100 to-amber-200 dark:from-gray-700 dark:to-gray-600 rounded-md shadow-md">
              {book.cover}
            </div>
          )}
        </div>
        <h3 className={`font-bold text-xs mb-1 ${isDarkMode ? 'text-white' : 'text-gray-900'} line-clamp-2 group-hover:text-amber-700 text-center`}>
          {book.title}
        </h3>
        <p className={`text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-600'} mb-1 text-center`}>
          {book.author}
        </p>
        {book.series && (
          <p className={`text-xs ${isDarkMode ? 'text-amber-300' : 'text-amber-700'} mb-1 text-center font-medium`}>
            {book.series}
          </p>
        )}
      </div>

      {/* Delete button - positioned absolutely */}
      <button
        onClick={(e) => {
          e.stopPropagation();
          e.preventDefault();
          deleteBook(book.id);
        }}
        className={`absolute top-1 right-1 p-1 rounded-full opacity-0 group-hover:opacity-100 transition-all duration-200 ${
          isDarkMode ? 'bg-gray-700 hover:bg-gray-600 text-gray-300' : 'bg-gray-100 hover:bg-gray-200 text-gray-600'
        } hover:text-red-500`}
        title="Delete book"
      >
        <Trash2 size={12} />
      </button>
    </div>
  );

  // Library view component
  const LibraryView = () => (
    <div className={`h-screen overflow-y-auto ${isDarkMode ? 'bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900' : 'bg-gradient-to-br from-blue-50 via-white to-purple-50'}`}>
      {/* Header */}
      <div className={`backdrop-blur-xl border-b sticky top-0 z-40 ${
        isDarkMode 
          ? 'bg-gray-900/70 border-white/10' 
          : 'bg-white/70 border-gray-200/50'
      } p-4`}>
        <div className="flex items-center justify-between mb-4">
          <div>
            <h1 className={`text-2xl font-bold ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
              My Library
            </h1>
            <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              {books.length} {books.length === 1 ? 'book' : 'books'}
            </p>
          </div>
          <div className="flex items-center space-x-2">
            {/* Filter Dropdown */}
            <select
              value={libraryFilter}
              onChange={(e) => setLibraryFilter(e.target.value)}
              className={`px-3 py-2 rounded-xl backdrop-blur-md border transition-all duration-300 text-sm ${
                isDarkMode 
                  ? 'bg-gray-800/50 border-white/10 text-white hover:bg-gray-700/70 hover:border-white/20' 
                  : 'bg-white/50 border-gray-200/30 text-gray-900 hover:bg-white/70 hover:border-gray-300/50'
              }`}
              title="Filter library"
            >
              <option value="all">All Books</option>
              <option value="recent">Recently Opened</option>
              <option value="author">By Author</option>
              <option value="title">By Title</option>
              <option value="series">By Series</option>
            </select>
            
            <button
              onClick={() => setLibraryView(libraryView === 'grid' ? 'list' : 'grid')}
              className={`p-2 rounded-xl backdrop-blur-md border transition-all duration-300 ${
                isDarkMode 
                  ? 'bg-gray-800/50 border-white/10 hover:bg-gray-700/70 hover:border-white/20' 
                  : 'bg-white/50 border-gray-200/30 hover:bg-white/70 hover:border-gray-300/50'
              }`}
              title={`Switch to ${libraryView === 'grid' ? 'list' : 'grid'} view`}
            >
              {libraryView === 'grid' ? <List size={20} /> : <Grid size={20} />}
            </button>
            <button
              onClick={() => setIsDarkMode(!isDarkMode)}
              className={`p-2 rounded-xl backdrop-blur-md border transition-all duration-300 ${
                isDarkMode 
                  ? 'bg-gray-800/50 border-white/10 hover:bg-gray-700/70 hover:border-white/20' 
                  : 'bg-white/50 border-gray-200/30 hover:bg-white/70 hover:border-gray-300/50'
              }`}
              title={`Switch to ${isDarkMode ? 'light' : 'dark'} mode`}
            >
              {isDarkMode ? <Sun size={20} /> : <Moon size={20} />}
            </button>
            <div className="relative">
              <input
                type="file"
                accept=".epub,.pdf,.html,.htm"
                onChange={handleFileUpload}
                className="hidden"
                id="file-upload"
                disabled={loading}
              />
              <label
                htmlFor="file-upload"
                className={`inline-flex items-center space-x-2 px-4 py-2 rounded-xl backdrop-blur-md border cursor-pointer transition-all duration-300 ${
                  loading ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105'
                } ${
                  isDarkMode 
                    ? 'bg-amber-900/60 border-amber-500/30 hover:bg-amber-800/70 hover:border-amber-400/50 text-amber-100' 
                    : 'bg-amber-900/80 border-amber-600/40 hover:bg-amber-800/90 hover:border-amber-500/60 text-amber-50'
                }`}
              >
                {loading ? <Loader2 size={16} className="animate-spin" /> : <Plus size={16} />}
                <span className="text-sm">Add Book</span>
              </label>
            </div>
          </div>
        </div>

        {/* Search Bar */}
        <div className="relative">
          <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`} size={20} />
          <input
            type="text"
            placeholder="Search by title, author, or tags..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className={`w-full pl-10 pr-4 py-3 rounded-xl backdrop-blur-md border transition-all duration-300 ${
              isDarkMode 
                ? 'bg-gray-800/50 text-white placeholder-gray-400 border-white/20 focus:border-white/40 focus:bg-gray-800/70' 
                : 'bg-white/50 text-gray-900 placeholder-gray-500 border-gray-200/50 focus:border-gray-300/70 focus:bg-white/70'
            } focus:outline-none focus:ring-2 focus:ring-amber-600/30`}
          />
        </div>
      </div>

      {/* Books Content */}
      <div className="p-4 pb-8">
        {loading && (
          <div className="text-center py-8">
            <Loader2 size={32} className={`animate-spin mx-auto mb-2 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`} />
            <p className={`${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              Processing your book...
            </p>
          </div>
        )}

        {!loading && filteredBooks.length === 0 && !searchQuery && (
          <div className={`text-center py-16 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
            <Book size={64} className="mx-auto mb-4 opacity-50" />
            <h3 className="text-xl font-semibold mb-2">No Books Yet</h3>
            <p className="mb-4">Add your first EPUB, PDF, or HTML book to get started</p>
            <label
              htmlFor="file-upload-empty"
              className={`inline-flex items-center space-x-2 px-6 py-3 rounded-xl backdrop-blur-md border cursor-pointer transition-all duration-300 hover:scale-105 ${
                isDarkMode 
                  ? 'bg-amber-900/60 border-amber-500/30 hover:bg-amber-800/70 hover:border-amber-400/50 text-amber-100' 
                  : 'bg-amber-900/80 border-amber-600/40 hover:bg-amber-800/90 hover:border-amber-500/60 text-amber-50'
              }`}
            >
              <Plus size={20} />
              <span>Add Your First Book</span>
            </label>
            <input
              type="file"
              accept=".epub,.pdf,.html,.htm"
              onChange={handleFileUpload}
              className="hidden"
              id="file-upload-empty"
            />
          </div>
        )}

        {!loading && filteredBooks.length === 0 && searchQuery && (
          <div className={`text-center py-16 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
            <Search size={64} className="mx-auto mb-4 opacity-50" />
            <h3 className="text-xl font-semibold mb-2">No Results Found</h3>
            <p>No books match your search for "{searchQuery}"</p>
          </div>
        )}

        {!loading && filteredBooks.length > 0 && (
          <div className="pb-4">
            {libraryView === 'grid' ? (
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-4">
                {filteredBooks.map(book => (
                  <BookCard key={book.id} book={book} />
                ))}
              </div>
            ) : (
              <div className="space-y-2">
                {filteredBooks.map(book => (
                  <div
                    key={book.id}
                    onClick={() => openBook(book)}
                    className={`backdrop-blur-md rounded-2xl border transition-all duration-300 hover:scale-[1.02] p-3 flex items-center space-x-3 cursor-pointer group relative ${
                      deletingBookId === book.id ? 'opacity-50 scale-98' : ''
                    } ${
                      isDarkMode 
                        ? 'bg-gray-800/30 border-white/10 hover:bg-gray-800/50 hover:border-white/20' 
                        : 'bg-white/40 border-gray-200/30 hover:bg-white/60 hover:border-gray-300/50'
                    }`}
                  >
                    <div className="flex-shrink-0">
                      {book.cover && book.cover.startsWith('data:') ? (
                        <div className="relative w-8 aspect-[2/3] overflow-hidden rounded group-hover:scale-110 transition-transform duration-200 shadow-sm">
                          <img 
                            src={book.cover} 
                            alt={`Cover of ${book.title}`}
                            className="w-full h-full object-cover"
                            onError={(e) => {
                              // Fallback to emoji if image fails to load
                              e.target.parentElement.style.display = 'none';
                              e.target.parentElement.nextSibling.style.display = 'flex';
                            }}
                          />
                        </div>
                      ) : null}
                      <div 
                        className={`w-8 aspect-[2/3] flex items-center justify-center text-2xl group-hover:scale-110 transition-transform duration-200 bg-gradient-to-br from-amber-100 to-amber-200 dark:from-gray-700 dark:to-gray-600 rounded shadow-sm ${
                          book.cover && book.cover.startsWith('data:') ? 'hidden' : ''
                        }`}
                      >
                        {book.cover}
                      </div>
                    </div>
                    <div className="flex-1 min-w-0">
                      <h3 className={`font-bold text-sm truncate ${isDarkMode ? 'text-white' : 'text-gray-900'} group-hover:text-amber-700`}>
                        {book.title}
                      </h3>
                      <p className={`text-xs truncate ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        {book.author}
                      </p>
                      {book.series && (
                        <p className={`text-xs truncate ${isDarkMode ? 'text-amber-300' : 'text-amber-700'} font-medium`}>
                          {book.series}
                        </p>
                      )}
                      {book.description && (
                        <p className={`text-xs mt-1 line-clamp-2 ${isDarkMode ? 'text-gray-500' : 'text-gray-500'}`}>
                          {book.description}
                        </p>
                      )}
                    </div>
                    
                    {/* Delete button - positioned absolutely */}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        deleteBook(book.id);
                      }}
                      className={`absolute top-3 right-3 p-1 rounded-lg opacity-0 group-hover:opacity-100 transition-all duration-200 ${
                        isDarkMode ? 'bg-gray-700 hover:bg-gray-600 text-gray-300' : 'bg-gray-100 hover:bg-gray-200 text-gray-600'
                      } hover:text-red-500`}
                      title="Delete book"
                    >
                      <Trash2 size={12} />
                    </button>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );

  // Reader view component
  const ReaderView = () => {
    const currentChapterData = selectedBook?.chapters[currentChapter];
    const bookBookmarks = bookmarks[selectedBook?.id] || {};
    const isBookmarked = bookBookmarks[`${currentChapter}-${currentPage}`];
    const bookmarksList = Object.entries(bookBookmarks).map(([key, bookmark]) => ({
      key,
      ...bookmark
    })).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    return (
      <div className={`h-full flex flex-col ${isDarkMode ? 'bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 text-white' : 'bg-gradient-to-br from-blue-50 via-white to-purple-50 text-gray-900'}`}>
        {/* Reader Header */}
        <div className={`backdrop-blur-xl border-b sticky top-0 z-40 ${
          isDarkMode 
            ? 'bg-gray-900/70 border-white/10' 
            : 'bg-white/70 border-gray-200/50'
        } p-4 flex justify-between items-center`}>
          <button
            onClick={closeBook}
            className={`p-2 rounded-xl backdrop-blur-md border transition-all duration-300 ${
              isDarkMode 
                ? 'bg-gray-800/50 border-white/10 hover:bg-gray-700/70 hover:border-white/20' 
                : 'bg-white/50 border-gray-200/30 hover:bg-white/70 hover:border-gray-300/50'
            }`}
            title="Back to library"
          >
            <ChevronLeft size={20} />
          </button>

          <div className="text-center flex-1 mx-4">
            <h2 className="font-bold text-lg truncate">{selectedBook?.title}</h2>
            <p className={`text-sm truncate ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              {selectedBook?.author}
            </p>
          </div>

          <div className="flex items-center space-x-2">
            <button
              onClick={() => setShowChapters(!showChapters)}
              className={`p-2 rounded-xl backdrop-blur-md border transition-all duration-300 ${
                isDarkMode 
                  ? 'bg-gray-800/50 border-white/10 hover:bg-gray-700/70 hover:border-white/20' 
                  : 'bg-white/50 border-gray-200/30 hover:bg-white/70 hover:border-gray-300/50'
              }`}
              title="Table of contents"
            >
              <Menu size={20} />
            </button>
            <button
              onClick={toggleBookmark}
              className={`p-2 rounded-xl backdrop-blur-md border transition-all duration-300 ${
                isBookmarked 
                  ? 'text-yellow-500 bg-yellow-500/20 border-yellow-500/30' 
                  : isDarkMode 
                    ? 'bg-gray-800/50 border-white/10 hover:bg-gray-700/70 hover:border-white/20' 
                    : 'bg-white/50 border-gray-200/30 hover:bg-white/70 hover:border-gray-300/50'
              }`}
              title={isBookmarked ? 'Remove bookmark' : 'Add bookmark'}
            >
              <Bookmark size={20} fill={isBookmarked ? 'currentColor' : 'none'} />
            </button>
            <button
              onClick={() => setShowSettings(!showSettings)}
              className={`p-2 rounded-xl backdrop-blur-md border transition-all duration-300 ${
                isDarkMode 
                  ? 'bg-gray-800/50 border-white/10 hover:bg-gray-700/70 hover:border-white/20' 
                  : 'bg-white/50 border-gray-200/30 hover:bg-white/70 hover:border-gray-300/50'
              }`}
              title="Reading settings"
            >
              <Settings size={20} />
            </button>
          </div>
        </div>

        {/* Chapter Navigation Panel */}
        {showChapters && selectedBook?.chapters && (
          <div className={`backdrop-blur-xl border-b max-h-80 overflow-y-auto ${
            isDarkMode 
              ? 'bg-gray-900/80 border-white/10' 
              : 'bg-white/80 border-gray-200/50'
          }`}>
            <div className="p-4">
              <div className="flex justify-between items-center mb-3">
                <div className="flex space-x-4">
                  <button
                    onClick={() => setShowChapters('chapters')}
                    className={`px-3 py-1 rounded-xl text-sm font-medium backdrop-blur-md border transition-all duration-300 ${
                      showChapters === 'chapters' || showChapters === true
                        ? isDarkMode 
                          ? 'bg-amber-900/60 text-amber-100 border-amber-500/30' 
                          : 'bg-amber-900/80 text-amber-50 border-amber-600/40'
                        : isDarkMode 
                          ? 'text-gray-400 hover:text-gray-300 bg-gray-800/30 border-white/10 hover:bg-gray-700/50' 
                          : 'text-gray-600 hover:text-gray-500 bg-white/30 border-gray-200/30 hover:bg-white/50'
                    }`}
                  >
                    Chapters
                  </button>
                  <button
                    onClick={() => setShowChapters('bookmarks')}
                    className={`px-3 py-1 rounded-xl text-sm font-medium backdrop-blur-md border transition-all duration-300 ${
                      showChapters === 'bookmarks'
                        ? isDarkMode 
                          ? 'bg-amber-900/60 text-amber-100 border-amber-500/30' 
                          : 'bg-amber-900/80 text-amber-50 border-amber-600/40'
                        : isDarkMode 
                          ? 'text-gray-400 hover:text-gray-300 bg-gray-800/30 border-white/10 hover:bg-gray-700/50' 
                          : 'text-gray-600 hover:text-gray-500 bg-white/30 border-gray-200/30 hover:bg-white/50'
                    }`}
                  >
                    Bookmarks ({bookmarksList.length})
                  </button>
                </div>
                <button
                  onClick={() => setShowChapters(false)}
                  className={`p-1 rounded ${isDarkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-100'}`}
                >
                  <ChevronLeft size={16} />
                </button>
              </div>

              {(showChapters === 'chapters' || showChapters === true) && (
                <div className="space-y-1">
                  {selectedBook.chapters.map((chapter, index) => (
                    <button
                      key={chapter.id}
                      onClick={() => goToChapter(index)}
                      className={`w-full text-left px-3 py-2 rounded-xl backdrop-blur-md border transition-all duration-300 text-sm ${
                        currentChapter === index
                          ? isDarkMode 
                            ? 'bg-amber-900/60 text-amber-100 border-amber-500/30' 
                            : 'bg-amber-900/80 text-amber-50 border-amber-600/40'
                          : isDarkMode 
                            ? 'hover:bg-gray-700/50 text-gray-300 bg-gray-800/20 border-white/10 hover:border-white/20' 
                            : 'hover:bg-white/50 text-gray-700 bg-white/20 border-gray-200/30 hover:border-gray-300/50'
                      }`}
                    >
                      <div className="flex justify-between items-center">
                        <span className="truncate">{chapter.title}</span>
                      </div>
                    </button>
                  ))}
                </div>
              )}

              {showChapters === 'bookmarks' && (
                <div className="space-y-1">
                  {bookmarksList.length === 0 ? (
                    <div className={`text-center py-8 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                      <Bookmark size={32} className="mx-auto mb-2 opacity-50" />
                      <p className="text-sm">No bookmarks yet</p>
                      <p className="text-xs">Click the bookmark button while reading to save your place</p>
                    </div>
                  ) : (
                    bookmarksList.map((bookmark) => (
                      <button
                        key={bookmark.key}
                        onClick={() => goToBookmark(bookmark)}
                        className={`w-full text-left px-3 py-2 rounded-xl backdrop-blur-md border transition-all duration-300 text-sm ${
                          isDarkMode 
                            ? 'hover:bg-gray-700/50 text-gray-300 bg-gray-800/20 border-white/10 hover:border-white/20' 
                            : 'hover:bg-white/50 text-gray-700 bg-white/20 border-gray-200/30 hover:border-gray-300/50'
                        }`}
                      >
                        <div className="flex items-start justify-between">
                          <div className="flex-1 min-w-0">
                            <div className="truncate font-medium">{bookmark.chapterTitle}</div>
                            <div className={`text-xs ${isDarkMode ? 'text-gray-500' : 'text-gray-500'}`}>
                              Page {bookmark.page} • {new Date(bookmark.timestamp).toLocaleDateString()}
                            </div>
                          </div>
                          <Bookmark size={14} className="text-yellow-500 ml-2 flex-shrink-0" />
                        </div>
                      </button>
                    ))
                  )}
                </div>
              )}
            </div>
          </div>
        )}

        {/* Settings Panel */}
        {showSettings && (
          <div className={`backdrop-blur-xl border-b p-4 ${
            isDarkMode 
              ? 'bg-gray-900/80 border-white/10' 
              : 'bg-white/80 border-gray-200/50'
          }`}>
            <div className="max-w-4xl mx-auto">
              <div className="flex justify-between items-center mb-4">
                <h3 className={`font-bold ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                  Reading Settings
                </h3>
                <button
                  onClick={() => setShowSettings(false)}
                  className={`p-1 rounded ${isDarkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-100'}`}
                >
                  <ChevronLeft size={16} />
                </button>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Font Family */}
                <div className="space-y-2">
                  <label className={`text-sm font-medium ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}>
                    Font Family
                  </label>
                  <select
                    value={fontFamily}
                    onChange={(e) => setFontFamily(e.target.value)}
                    className={`w-full px-3 py-2 rounded-lg ${
                      isDarkMode ? 'bg-gray-700 text-white border-gray-600' : 'bg-gray-100 border-gray-300'
                    } border focus:outline-none focus:ring-2 focus:ring-amber-600`}
                  >
                    <option value="serif">Serif (Times)</option>
                    <option value="sans-serif">Sans Serif (Arial)</option>
                    <option value="monospace">Monospace (Courier)</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Palatino">Palatino</option>
                  </select>
                </div>

                {/* Font Size */}
                <div className="space-y-2">
                  <label className={`text-sm font-medium ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}>
                    Font Size: {fontSize}px
                  </label>
                  <div className="flex items-center space-x-2">
                    <span className="text-sm">A</span>
                    <input
                      type="range"
                      min="12"
                      max="28"
                      value={fontSize}
                      onChange={(e) => setFontSize(Number(e.target.value))}
                      className="flex-1 accent-amber-950"
                    />
                    <span className="text-xl">A</span>
                  </div>
                </div>

                {/* Line Height */}
                <div className="space-y-2">
                  <label className={`text-sm font-medium ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}>
                    Line Spacing: {lineHeight}
                  </label>
                  <div className="flex items-center space-x-2">
                    <AlignLeft size={16} />
                    <input
                      type="range"
                      min="1.2"
                      max="2.0"
                      step="0.1"
                      value={lineHeight}
                      onChange={(e) => setLineHeight(Number(e.target.value))}
                      className="flex-1 accent-amber-950"
                    />
                    <AlignLeft size={20} />
                  </div>
                </div>
              </div>

              {/* Theme Toggle */}
              <div className="mt-6 pt-4 border-t border-gray-200/30 dark:border-white/10">
                <button
                  onClick={() => setIsDarkMode(!isDarkMode)}
                  className={`flex items-center space-x-3 px-4 py-2 rounded-xl backdrop-blur-md border transition-all duration-300 ${
                    isDarkMode 
                      ? 'bg-gray-700/50 hover:bg-gray-600/60 border-white/10 hover:border-white/20' 
                      : 'bg-white/50 hover:bg-white/70 border-gray-200/30 hover:border-gray-300/50'
                  }`}
                >
                  {isDarkMode ? <Sun size={20} /> : <Moon size={20} />}
                  <span>{isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}</span>
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Reading Content */}
        <div ref={contentScrollRef} className="flex-1 overflow-y-auto min-h-0">
          <div className="max-w-4xl mx-auto p-6 pb-8">
            <div
              className={`prose prose-lg max-w-none ${isDarkMode ? 'prose-invert' : ''}`}
              style={{
                fontSize: `${fontSize}px`,
                fontFamily: fontFamily,
                lineHeight: lineHeight,
                color: isDarkMode ? '#f3f4f6' : '#1f2937'
              }}
            >
              <style dangerouslySetInnerHTML={{
                __html: `
                  .prose p {
                    text-indent: 1.0em;
                    margin-bottom: 0.5em;
                  }
                  .prose p:first-child,
                  .prose h1 + p,
                  .prose h2 + p,
                  .prose h3 + p,
                  .prose h4 + p,
                  .prose h5 + p,
                  .prose h6 + p,
                  .prose blockquote p,
                  .prose li p {
                    text-indent: 0;
                  }
                `
              }} />
              <div dangerouslySetInnerHTML={{ __html: currentChapterData?.content || "No content available" }} />
            </div>
          </div>
        </div>

        {/* Floating Navigation Buttons */}
        <div className="fixed bottom-6 left-6 z-30">
          <button
            onClick={prevChapter}
            disabled={currentChapter === 0}
            className={`p-3 rounded-2xl backdrop-blur-xl border transition-all duration-300 hover:scale-110 ${
              currentChapter === 0
                ? 'opacity-30 cursor-not-allowed'
                : isDarkMode
                ? 'bg-gray-800/80 text-white border-white/20 hover:bg-gray-700/90 hover:border-white/30 shadow-xl'
                : 'bg-white/80 text-gray-900 border-gray-200/50 hover:bg-white/90 hover:border-gray-300/70 shadow-xl'
            }`}
            title="Previous Chapter"
          >
            <ChevronLeft size={20} />
          </button>
        </div>

        <div className="fixed bottom-6 right-6 z-30">
          <button
            onClick={nextChapter}
            disabled={currentChapter === selectedBook?.chapters.length - 1}
            className={`p-3 rounded-2xl backdrop-blur-xl border transition-all duration-300 hover:scale-110 ${
              currentChapter === selectedBook?.chapters.length - 1
                ? 'opacity-30 cursor-not-allowed'
                : isDarkMode
                ? 'bg-gray-800/80 text-white border-white/20 hover:bg-gray-700/90 hover:border-white/30 shadow-xl'
                : 'bg-white/80 text-gray-900 border-gray-200/50 hover:bg-white/90 hover:border-gray-300/70 shadow-xl'
            }`}
            title="Next Chapter"
          >
            <ChevronRight size={20} />
          </button>
        </div>
      </div>
    );
  };

  return (
    <div className="w-full h-screen overflow-hidden">
      {currentView === 'library' ? <LibraryView /> : <ReaderView />}
      <Notification message={error} />
    </div>
  );
};

export default BookReaderApp;